#!/usr/bin/env bash
# Fix the jupyter kernel spec configuration file when it does not point to the appropriate conda env python path

source ~/miniconda3/etc/profile.d/conda.sh

add_to_ipykernel () {
  # Possibly add it the Jupyter kernels:
   conda activate ${1}
   echo ${1}
   python -m ipykernel install --user --name=$1

   # Check installation of the kernel
}

fix_kernel_path (){
  ENV=${1}

  kernelspec="$(jupyter kernelspec list | grep ${ENV})"
  echo "${kernelspec}"
  IFS=' ' read -ra ADDR <<< "$kernelspec"
  kernel_path="${ADDR[1]}"
  #echo "${kernel_path}"
  kernel_cfg_file="${kernel_path}/kernel.json"
#  echo "${kernel_cfg_file}"
  python_path="$(more ${kernel_cfg_file} | jq .argv[0] | sed 's/\"//g')"
  #echo ${python_path} | sed 's/"//g'
#  echo "${python_path}"
  DIR="$(dirname ${python_path})"
  FILE="$(basename ${python_path})"
  #echo "[${DIR}] [${FILE}]"
  IFS='/' read -r -a parts <<< "$DIR"
  #for index in "${!parts[@]}"
  #do
  #    echo "$index ${parts[index]}"
  #done
  #echo "${parts[-2]}"
  # We expect: /Users/gmaze/miniconda3/envs/<ENV>/bin
  if [ "${parts[-2]}" = ${ENV} ]; then
    echo "kernel spec OK"
  else
#    echo "NOT OK !"
    parts[-2]=${ENV}  # update with appropriate python path
    NEW_DIR=$(IFS='/' ; echo "${parts[*]}")
    new_python_path="${NEW_DIR}/${FILE}"

    while true; do
      printf "Replace: \n${python_path} \nwith: \n${new_python_path}\n"
      read -p "Do you confirm ? [Yy/Nn] " yn
      case $yn in
          [Yy]* )
            cp -f ${kernel_cfg_file} "${kernel_cfg_file}.bak"
            tmp=$(mktemp)
            jq --arg a "$new_python_path" '.argv[0] = $a' ${kernel_cfg_file} > "$tmp" && mv "$tmp" ${kernel_cfg_file}
            break;;
          [Nn]* ) exit;;
          * ) echo "Please answer yes [Yy] or no [Nn]";;
      esac
    done

  fi
}